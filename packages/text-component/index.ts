/**
 * @see https://minecraft.gamepedia.com/Commands#Raw_JSON_text
 */
export interface TextComponentFrame {
    /**
     * A string representing raw text to display directly in chat. Note that selectors such as "@a" and "@p" are not translated into player names; use selector instead. Can use escape characters, such as \n for newline (enter), \t for tab, etc.
     */
    text: string;
    /**
     * The translation identifier of text to be displayed using the player's selected language. This identifier is the same as the identifiers found in lang files from assets or resource packs. Ignored when  text exist in the root object.
     */
    translate?: string;
    /**
     * A list of chat component arguments and/or string arguments to be used by  translate. Useless otherwise.
     *
     * The arguments are text corresponding to the arguments used by the translation string in the current language, in order (for example, the first list element corresponds to "%1$s" in a translation string). Argument structure repeats this raw JSON text structure.
     */
    with?: string[];
    score?: {
        name: string,
        objective: string,
        value: string,
    };
    selector?: string;
    keybind?: string;
    /**
     *  A string indicating the NBT path used for looking up NBT values from an entity or a block entity. Ignored when any of the previous fields exist in the root object.
     */
    nbt?: string;
    /**
     * A string specifying the coordinates of the block entity from which the NBT value is obtained. The coordinates can be absolute or relative. Useless if  nbt is absent.
     */
    block?: string;
    /**
     * A string specifying the target selector for the entity from which the NBT value is obtained. Useless if  nbt is absent.
     */
    entity?: string;
    /**
     * A list element whose structure repeats this raw JSON text structure. Note that all properties of this object are inherited by children except for text, extra, translate, with, and score. This means that children retain the same formatting and events as this object unless they explicitly override them.
     */
    extra?: TextComponentFrame[];
    /**
     * The color to render this text in. Valid values are "black", "dark_blue", "dark_green", "dark_aqua", "dark_red", "dark_purple", "gold", "gray", "dark_gray", "blue", "green", "aqua", "red", "light_purple", "yellow", "white", and "reset" (cancels out the effects of colors used by parent objects). Technically, "bold", "italic", "underlined", "strikethrough", and "obfuscated" are also accepted, but it may be better practice to use the tags below for such formats.
     */
    color?: string;
    bold?: boolean;
    italic?: boolean;
    underlined?: boolean;
    strikethrough?: boolean;
    obfuscated?: boolean;
    /**
     * When the text is shift-clicked by a player, this string is inserted in their chat input. It does not overwrite any existing text the player was writing.
     */
    insertion?: string;
    /**
     *  Allows for events to occur when the player clicks on text.
     */
    clickEvent?: {
        /**
         * The action to perform when clicked.
         * Valid values are
         * - "open_url" (opens value as a URL in the player's default web browser),
         * - "open_file" (opens the value file on the user's computer),
         * - "run_command" (has value entered in chat as though the player typed it themselves. This can be used to run commands, provided the player has the required permissions),
         * - "change_page" (can be used only in written books) changes to page value if that page exists,
         * - "suggest_command" (similar to "run_command" but it cannot be used in a written book, the text appears only in the player's chat input and it is not automatically entered. Unlike insertion, this replaces the existing contents of the chat input),
         * - "copy_to_clipboard"‌[upcoming: 1.15] (copy the value to the clipboard). "open_file" is used in messages automatically generated by the game (e.g. on taking a screenshot) and cannot be used in commands or signs.
         */
        action: TextComponent.ClickEventAction;
        /**
         * The URL, file, chat, command or book page used by the specified action. Note that commands must be prefixed with the usual "/" slash.
         */
        value: string;
    };
    hoverEvent?: {
        /**
         * The type of tooltip to show. Valid values are
         * - "show_text" (shows raw JSON text),
         * - "show_item" (shows the tooltip of an item that can have NBT tags),
         * - "show_entity" (shows an entity's name, possibly its type, and its UUID).
         */
        action: TextComponent.HoverEventAction;
        /**
         * The formatting of this tag varies depending on the action. Note that "show_text" is the only action to support an Object as the value; all other action values are Strings and should thus be wrapped in quotes.
         *
         * - "show_text" can be either a raw string of text or an object with the same formatting as this base object. Note that clickEvent and hoverEvent do not function within the tooltip, but the formatting and extra tags still work.
         * - "show_item" can be a string formatted like item NBT data. Contains the "id" tag, and optionally the "Damage" tag and "tag" tag (which is the same compound used as "dataTag" in the /give command).
         * - "show_entity" can be string formatted like a compound with the string values "type" (such as "Zombie"), "name", and "id" (should be an entity UUID, but can actually be any string).
         */
        value: string | TextComponent;
    };
}

class TextFormat<T extends keyof Style> {
    static readonly CONTROL_STRING = "§";
    constructor(readonly key: T, readonly value: Style[T], readonly name: string, readonly code: string, readonly cssForeground: string, readonly cssBackground?: string) { }
    applyToStyle(style: Style) { style[this.key] = this.value; }
    matchStyle(style: Style) { return style[this.key] === this.value; }

    static readonly BLACK = new TextFormat("color", "black", "BLACK", "0", "color: #000000;", "color: #000000;");
    static readonly DARK_BLUE = new TextFormat("color", "dark_blue", "DARK_BLUE", "1", "color: #0000AA;", "color: #00002A;");
    static readonly DARK_GREEN = new TextFormat("color", "DARK_GREEN", "DARK_GREEN", "2", "color: #00AA00;", "color: #002A00;");
    static readonly DARK_AQUA = new TextFormat("color", "dark_aqua", "DARK_AQUA", "3", "color: #00AAAA;", "color: #002A2A;");
    static readonly DARK_RED = new TextFormat("color", "dark_red", "DARK_RED", "4", "color: #AA0000;", "color: #2A0000;");
    static readonly DARK_PURPLE = new TextFormat("color", "dark_purple", "DARK_PURPLE", "5", "color: #AA00AA;", "color: #2A002A;");
    static readonly GOLD = new TextFormat("color", "gold", "GOLD", "6", "color: #FFAA00;", "color: #2A2A00;");
    static readonly GRAY = new TextFormat("color", "gray", "GRAY", "7", "color: #AAAAAA;", "color: #2A2A2A;");
    static readonly DARK_GRAY = new TextFormat("color", "dark_gray", "DARK_GRAY", "8", "color: #555555;", "color: #151515;");
    static readonly BLUE = new TextFormat("color", "blue", "BLUE", "9", "color: #5555FF;", "color: #15153F;");
    static readonly GREEN = new TextFormat("color", "green", "GREEN", "a", "color: #55FF55;", "color: #153F15;");
    static readonly AQUA = new TextFormat("color", "aqua", "AQUA", "b", "color: #55FFFF;", "color: #153F3F;");
    static readonly RED = new TextFormat("color", "red", "RED", "c", "color: #FF5555;", "color: #3F1515;");
    static readonly LIGHT_PURPLE = new TextFormat("color", "light_purple", "LIGHT_PURPLE", "d", "color: #FF55FF;", "color: #3F153F;");
    static readonly YELLOW = new TextFormat("color", "yellow", "YELLOW", "e", "color: #FFFF55;", "color: #3F3F15;");
    static readonly WHITE = new TextFormat("color", "white", "WHITE", "f", "color: #FFFFFF;", "color: #3F3F3F;");
    static readonly OBFUSCATED = new TextFormat("obfuscated", true, "OBFUSCATED", "k", "");
    static readonly BOLD = new TextFormat("bold", true, "BOLD", "l", "font-weight: bold;");
    static readonly STRIKETHROUGH = new TextFormat("strikethrough", true, "STRIKETHROUGH", "m", "text-decoration:line-through;");
    static readonly UNDERLINE = new TextFormat("underlined", true, "UNDERLINE", "n", "text-decoration: underline;");
    static readonly ITALIC = new TextFormat("italic", true, "ITALIC", "o", "font-style: italic;");
    static readonly RESET = {
        name: "RESET",
        code: "r",
        applyToStyle(style: Style) {
            style.bold = false;
            style.strikethrough = false;
            style.underlined = false;
            style.italic = false;
            style.obfuscated = false;
            style.color = undefined;
        },
        matchStyle(style: Style) { return false; },
        cssBackground: "",
        cssForeground: "",
        toString() { return `${TextFormat.CONTROL_STRING}r`; }
    };

    static readonly list = [
        TextFormat.BLACK,
        TextFormat.DARK_BLUE,
        TextFormat.DARK_GREEN,
        TextFormat.DARK_AQUA,
        TextFormat.DARK_RED,
        TextFormat.DARK_PURPLE,
        TextFormat.GOLD,
        TextFormat.GRAY,
        TextFormat.DARK_GRAY,
        TextFormat.BLUE,
        TextFormat.GREEN,
        TextFormat.AQUA,
        TextFormat.RED,
        TextFormat.LIGHT_PURPLE,
        TextFormat.YELLOW,
        TextFormat.WHITE,
        TextFormat.OBFUSCATED,
        TextFormat.BOLD,
        TextFormat.STRIKETHROUGH,
        TextFormat.UNDERLINE,
        TextFormat.ITALIC,
        TextFormat.RESET,
    ];

    static fromCode(code: string) {
        const seq = "0123456789abcdefklmnor";
        const index = seq.indexOf(code);
        if (!index) { return undefined; }
        return this.list[seq.indexOf(code)];
    }

    toString() {
        return `${TextFormat.CONTROL_STRING}${this.code}`;
    }
}


export interface Style {
    /**
     * The friendly name of the color, like `light_purple` or `red`
     */
    color?: string;
    bold?: boolean;
    italic?: boolean;
    underlined?: boolean;
    strikethrough?: boolean;
    obfuscated?: boolean;
}

export namespace Style {
    /**
     * Grab style info in JSON `TextComponentFrame`.
     */
    export function of(obj: Style | TextComponentFrame): Style {
        return {
            color: obj.color,
            bold: obj.bold,
            italic: obj.italic,
            strikethrough: obj.strikethrough,
            underlined: obj.underlined,
            obfuscated: obj.obfuscated,
        }
    }
    /**
     * Get Minecraft style code for the style
     */
    export function getCode(style: Style): string {
        let code = "";
        for (const l of TextFormat.list) {
            if (l.matchStyle(style)) {
                code += l;
            }
        }
        return code;
    }
}

export interface TextComponent {
    /**
     * Gets the style of this component. Returns a direct reference; changes to this style will modify the style of this
     * component (IE, there is no need to call {@link #style(Style)} again after modifying it).
     * <p>
     * If this component's style is currently <code>null</code>, it will be initialized to the default style, and the
     * parent style of all sibling components will be set to that style. (IE, changes to this style will also be
     * reflected in sibling components.)
     * <p>
     * This method never returns <code>null</code>.
     */
    style: Style;
    text: string;
    siblings: TextComponent[];
    clickEvent?: TextComponent.Event<string>;
    hoverEvent?: TextComponent.Event<string | TextComponent>;
    insertion?: string;
}

export namespace TextComponent {
    export type ClickEventAction = "open_file" | "open_url" | "run_command" | "suggest_command";
    export type HoverEventAction = "show_text" | "show_item" | "show_entity";

    export interface Event<T> {
        action: ClickEventAction | HoverEventAction;
        value: T;
    }

    export type RenderNode = {
        style: string; text: string; children: RenderNode[]
    };

    /**
     * Get suggest css style string for input style
     */
    export function getSuggestedCss(style: Style): string {
        const styles = [];
        for (const l of TextFormat.list) {
            if (l.matchStyle(style)) {
                styles.push(l.cssForeground.trim());
            }
        }
        return styles.filter((s) => s.length !== 0).join(" ");
    }

    /**
     * Render a text component into html style object
     * @returns the render node hint for html/css info
     */
    export function render(src: TextComponent): RenderNode {
        const children = new Array<RenderNode>();
        for (const component of src.siblings) {
            children.push(render(component));
        }
        return { children, text: src.text, style: getSuggestedCss(src.style) };
    }

    /**
     * Convert a text component to Minecraft specific formatted string like `§1colored§r`
     */
    export function toFormattedString(comp: TextComponent): string {
        let v = "";
        for (const component of flat(comp)) {
            const text = component.text;
            if (text.length !== 0) {
                v += `${Style.getCode(component.style)}${text}${TextFormat.RESET}`;
            }
        }
        return v;
    }

    /**
     * Flat all components in this component by DFS into a list.
     * @param component The root component
     */
    export function flat(component: TextComponent): TextComponent[] {
        const arr: TextComponent[] = [component];
        if (component.siblings.length !== 0) {
            for (const s of component.siblings) {
                arr.push(...flat(s));
            }
        }
        return arr;
    }


    /**
     * Convert json format (server motd) or string to TextComponent Object
     */
    export function from(obj: string | TextComponentFrame): TextComponent {
        if (typeof obj === "string") {
            return fromFormattedString(obj);
        }
        const text = obj.text || "";
        const style = Style.of(obj);
        const siblings = [];
        if (obj.extra instanceof Array) {
            for (const element of obj.extra) {
                siblings.push(from(element));
            }
        }
        return {
            text,
            style,
            siblings,
        };
    }

    function fromFormattedString(formatted: string): TextComponent {
        const firstCode = formatted.indexOf("§");
        if (firstCode === -1) { return new TextComponentString(formatted); }

        let builder: string = "";
        const style: Style = {
            bold: false,
            obfuscated: false,
            strikethrough: false,
            underlined: false,
            italic: false,
            color: undefined,
        }

        // function seekStyleLength(index: number) {
        //     if (formatted[index] !== TextFormat.CONTROL_STRING) {
        //         return 0;
        //     }
        //     let cur = index;
        //     while (formatted[cur] === TextFormat.CONTROL_STRING) {
        //         cur += 2;
        //     }
        //     return cur + 1 - index;
        // }

        const s: TextComponentString = new TextComponentString();
        for (let i = 0; i < formatted.length; i++) {
            const word = formatted.charCodeAt(i);
            if (word === 167 && i + 1 < formatted.length) {
                if (builder.length !== 0) {
                    s.append(new TextComponentString(builder, { ...style }));
                    builder = "";
                }
                const format = TextFormat.fromCode(formatted.charAt(i + 1).toLowerCase());
                if (format) { format.applyToStyle(style); }
                ++i; // ignore the next char
            } else {
                builder += formatted[i];
            }
        }
        if (builder.length !== 0) {
            s.append(new TextComponentString(builder, { ...style }));
        }
        return s;
    }
}

export class TextComponentString implements TextComponent {
    protected _siblings: TextComponent[] = new Array();
    private _style?: Style;

    static of(text: string = "", style?: Style, siblings?: TextComponent[]) {
        return new TextComponentString(text, style, siblings);
    }

    constructor(public readonly text: string = "", style?: Style, siblings?: TextComponent[]) {
        if (style) {
            this._style = style;
        }
        if (siblings) {
            this._siblings = siblings;
        }
    }

    toString(): string { return this.formatted; }

    set style(style: Style) {
        this._style = style;
    }
    get style() {
        if (this._style) {
            return this._style;
        }
        this._style = {};
        return this._style;
    }

    get iterator() {
        return TextComponent.flat(this);
    }

    get formatted(): string {
        return TextComponent.toFormattedString(this);
    }

    get siblings(): TextComponent[] { return this._siblings; }

    append(component: TextComponent | string): TextComponent {
        let comp: TextComponent;
        if (typeof component === "string") {
            comp = new TextComponentString(component);
        } else { comp = component; }
        this.siblings.push(comp);
        return this;
    }
}
